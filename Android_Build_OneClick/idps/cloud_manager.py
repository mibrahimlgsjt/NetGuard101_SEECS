"""
IDPS Cloud Defense System (Supabase Integration)
=================================================
Handles interaction with the Supabase Collaborative Threat Intelligence Database.

FEATURES:
1. Report Threats: Pushes local detection events to the cloud 'threat_intel' table.
2. Listen for Bans: (Future) Subscribes to 'active_bans' for real-time updates.

USAGE:
    from idps.cloud_manager import CloudDefenseManager
    CloudDefenseManager().report_threat("192.168.1.50", "MALWARE_SIGNATURE")
"""

import os
import threading
from datetime import datetime
import logging

try:
    from supabase import create_client, Client
    SUPABASE_AVAILABLE = True
except ImportError:
    SUPABASE_AVAILABLE = False
    print("Warning: 'supabase' library not installed. Cloud features disabled.")

# ==============================================================================
# CONFIGURATION (Auto-filled from Setup)
# ==============================================================================
# OFFICIAL SUPABASE INTEGRATION CREDENTIALS
PROJECT_REF = "pybgyjuonordoljnogdt"
SUPABASE_URL = f"https://{PROJECT_REF}.supabase.co"
# Using the Public Anon Key for Client-Side Integration (RLS Enabled)
SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InB5Ymd5anVvbm9yZG9sam5vZ2R0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjY1NDg1OTcsImV4cCI6MjA4MjEyNDU5N30.9VLzOc1lLjAfaka6TPnxJVJVaf1rGOCre_rs7vgJukM"

class CloudDefenseManager:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        # Singleton Pattern to share one connection
        with cls._lock:
            if cls._instance is None:
                cls._instance = super(CloudDefenseManager, cls).__new__(cls)
                cls._instance._initialized = False
            return cls._instance

    def __init__(self):
        if self._initialized:
            return
            
        self.client: Client = None
        self.enabled = False
        
        if SUPABASE_AVAILABLE:
            try:
                self.client = create_client(SUPABASE_URL, SUPABASE_KEY)
                self.enabled = True
                # Generate a random Reporter ID for this session if one doesn't exist
                # In a real app, this would be a persistent UUID stored in a config file.
                import uuid
                self.reporter_id = str(uuid.uuid4())
                print(f"INFO: Cloud Defense Active. Reporter ID: {self.reporter_id}")
            except Exception as e:
                print(f"ERROR: Failed to connect to Supabase: {e}")
                self.enabled = False
        
        self._initialized = True

    def report_threat(self, ip_address: str, threat_type: str):
        """
        Async fire-and-forget reporting of a threat.
        We use a thread to avoid blocking the main packet processing loop.
        """
        if not self.enabled:
            return

        def _send():
            try:
                # Calculate PKT Time (UTC+5)
                # Supabase expects ISO 8601 string
                from datetime import timedelta, timezone
                pkt_time = (datetime.now(timezone.utc) + timedelta(hours=5)).isoformat()

                data = {
                    "ip_address": ip_address,
                    "reporter_id": self.reporter_id,
                    "created_at": pkt_time # Explicitly setting timestamp to PKT
                    # 'subnet' is auto-generated by the database
                }
                # Insert into threat_intel table
                self.client.table("threat_intel").insert(data).execute()
                print(f"☁️  CLOUD: Reported threat {ip_address} to global intelligence at {pkt_time} (PKT).")
            except Exception as e:
                print(f"☁️  CLOUD ERROR: Failed to report threat: {e}")

        # Run in background thread
        threading.Thread(target=_send, daemon=True).start()

    def get_global_bans(self):
        """
        Fetch the current list of global bans.
        """
        if not self.enabled:
            return []
        
        try:
            response = self.client.table("active_bans").select("*").execute()
            return response.data
        except Exception as e:
            print(f"Error fetching global bans: {e}")
            return []

    def get_recent_threats(self, limit=50):
        """
        Fetch recent threats from Supabase to populate local logs.
        """
        if not self.enabled:
            return []
            
        try:
            # Fetch last N threats
            response = self.client.table("threat_intel").select("*").order("created_at", desc=True).limit(limit).execute()
            return response.data
        except Exception as e:
            print(f"☁️  CLOUD ERROR: Failed to fetch recent threats: {e}")
            return []

    def sign_in(self, email, password):
        """
        Authenticate user with Supabase.
        """
        if not self.enabled:
            return {"error": "Cloud services unavailable."}
        try:
            response = self.client.auth.sign_in_with_password({"email": email, "password": password})
            return {"user": response.user, "session": response.session}
        except Exception as e:
            return {"error": str(e)}

    def sign_up(self, email, password):
        """
        Register a new user with Supabase.
        """
        if not self.enabled:
            return {"error": "Cloud services unavailable."}
        try:
            response = self.client.auth.sign_up({"email": email, "password": password})
            if response.user:
                return {"user": response.user, "message": "Confirm your email to proceed."}
            return {"error": "Signup failed."}
        except Exception as e:
            return {"error": str(e)}
